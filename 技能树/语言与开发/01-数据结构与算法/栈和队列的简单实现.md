# 栈和队列的简单实现

[返回目录](../01-数据结构与算法.md)

---

## 栈

栈需要具备以下抽象数据类型

- push 将数据插入栈
- pop 删除并返回最后一个插入栈的元素
- top 返回最后一个插入栈的元素，但不删除
- size 返回栈中元素的个数
- isEmpty 判断栈是否为空
- isStackFull 判断栈中是否满

## 栈的应用场景

直接应用

- 符号匹配
- 中缀表达式转换为后缀表达式
- 计算后缀表达式
- 实现函数调用(包括递归)
- 求范围误差(极差)
- 浏览器中的访问页面历史记录
- 文本编辑器的撤销操作
- html 和 xml 中的标签匹配

间接应用

- 作为一个算法的辅助数据结构，例如树的遍历
- 其他数据结构的组成部分之一，例如使用栈模拟队列

## 实现方式

- 数组实现
- 动态数组实现
- 链表实现

比较他们的实现

数组的实现，各种操作都是常数时间开销，每隔一段时间的倍增操作开销较大

链表的实现，栈规模的增加和缩减都比较简单，各个操作也是常数时间开销，每个操作需要额外的空间和时间开销来处理指针。

不过我觉得两个种方式好像差不多。都是逐个读写，因为栈的特性不会存在遍历。

数组方式

```java
public class StackArray2 {

  // 成员属性
  private int top;
  private int capacity;
  private int[] array;

  // 成员方法
  public StackArray2() {
    capacity = 1;
    array = new int[capacity];
    top = -1;
  }

  public boolean isEmpty() {
    return top == -1;
  }

  public boolean isStackFull() {
    return top == array.length;
  }

  public void push(int data) throws Exception {
    if (isStackFull()) {
      throw new Exception("stack is full");
    } else {
      doubleStack();
      array[++top] = data;
    }
  }

  public int pop() throws Exception {
    if (isEmpty()) {
      throw new Exception("stack is empty");
    } else {
      return array[--top];
    }
  }

  public void deleteStack() {
    top = -1;
  }

  private void doubleStack() {
    if (capacity * 0.75 <= (top + 1)) {
      int[] newArray = new int[capacity * 2];
      System.arraycopy(array, 0, newArray, 0, capacity);
      capacity = capacity * 2;
      array = newArray;
    }
  }

  @Override
  public String toString() {
    return "StackArray2{" +
      "top=" + top +
      ", capacity=" + capacity +
      ", array=" + Arrays.toString(array) +
      '}';
  }
}
```

链表方式

```java
public class StackLinked1 {

  private static class StackLinkedNode {

    private final int data;
    private final StackLinkedNode next;

    public StackLinkedNode(int _data, StackLinkedNode _next) {
      this.data = _data;
      this.next = _next;
    }

    public int getData() {
      return data;
    }

    @Override
    public String toString() {
      return data + "->" + next;
    }
  }

  private StackLinkedNode head;

  public StackLinked1() {
    this.head = new StackLinkedNode(0, null);
  }

  public void push(int data) {
    if (head == null) {
      head = new StackLinkedNode(data, null);
    } else {
      head = new StackLinkedNode(data, head);
    }
  }

  public int pop() throws Exception {
    if (head == null) {
      throw new Exception("stack is empty");
    } else {
      int data = head.getData();
      head = head.next;
      return data;
    }
  }

  public int top() throws Exception {
    if (head == null) {
      throw new Exception("Stack is empty");
    } else {
      return head.getData();
    }
  }

  public boolean isEmpty() {
    return head == null;
  }

  public void deleteStack() {
    head = null;
  }
}
```